#define MAX_STRAND_VERTICES 16

precision highp float;

layout(local_size_x = 1, local_size_y = MAX_STRAND_VERTICES, local_size_z = 1) in;

layout(std430, binding = REST_POSITIONS_BUFFER_BINDING) buffer RestPositions
{
    vec4 data[];
} restPositions;

layout(std430, binding = POSITIONS_BUFFER_BINDING) buffer Positions
{
    vec4 data[];
} positions;

layout(std430, binding = PREVIOUS_POSITIONS_BUFFER_BINDING) buffer PreviousPositions
{
    vec4 data[];
} previousPositions;

layout(std430, binding = TANGENTS_DISTANCES_BINDING) buffer TangentsDistances
{
    vec4 data[];
} tangentsDistances;

layout(std430, binding = REF_VECTORS_BINDING) buffer RefVectors
{
    vec4 data[];
} refVectors;

layout(std430, binding = GLOBAL_ROTATIONS_BINDING) buffer GlobalRotations
{
    vec4 data[];
} globalRotations;

layout(std430, binding = DEBUG_BUFFER_BINDING) buffer DebugBuffer
{
    vec4 data[];
} debugBuffer;

uniform mat4 modelMatrix;
uniform int verticesPerStrand;
uniform float timeStep;
uniform float globalStiffness;
uniform float localStiffness;
uniform float damping;
uniform vec3 gravity;
uniform int lengthConstraintIterations;
uniform int localShapeIterations;
uniform mat4 windPyramid;
uniform float windMagnitude;
uniform float thetaX;
uniform float thetaY;
uniform float thetaZ;
uniform int simulationFrame;

shared vec4 sharedPositions[MAX_STRAND_VERTICES];

bool isMovable(vec4 position)
{
    return position.w > 0;
}

vec4 makeQuaternion(float angle, vec3 axis)
{
    vec4 quaternion = vec4(0.0, 0.0, 0.0, 0.0);
	float halfAngle = angle * 0.5f;
	quaternion.w = cos(halfAngle);
	quaternion.xyz = axis * sin(halfAngle);
	return quaternion;
}

vec4 inverseQuaternion(vec4 quaternion)
{
    float lengthSqr = quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
	if(lengthSqr < 0.001) {
	    return vec4(0, 0, 0, 1.0f);
	}

	quaternion.x = -quaternion.x / lengthSqr;
	quaternion.y = -quaternion.y / lengthSqr;
	quaternion.z = -quaternion.z / lengthSqr;
	quaternion.w = quaternion.w / lengthSqr;

	return quaternion;
}

vec3 multQuaternionAndVector(vec4 q, vec3 v)
{
    vec3 qvec = q.xyz;
    vec3 uv = cross(qvec, v);
    vec3 uuv = cross(qvec, uv);
    uv *= (2.0f * q.w);
    uuv *= 2.0f;

    return v + uv + uuv;
}

vec4 multQuaternionAndQuaternion(vec4 qA, vec4 qB)
{
    vec4 q;

    q.w = qA.w * qB.w - qA.x * qB.x - qA.y * qB.y - qA.z * qB.z;
    q.x = qA.w * qB.x + qA.x * qB.w + qA.y * qB.z - qA.z * qB.y;
    q.y = qA.w * qB.y + qA.y * qB.w + qA.z * qB.x - qA.x * qB.z;
    q.z = qA.w * qB.z + qA.z * qB.w + qA.x * qB.y - qA.y * qB.x;

    return q;
}

//returns a vec2
vec2 constraintMultiplier(vec4 p0, vec4 p1)
{
    if(isMovable(p0)) {
	    return isMovable(p1) ? vec2(0.5, 0.5) : vec2(1.0, 0.0);
	}
	else {
	    return isMovable(p1) ? vec2(0.0, 1.0) : vec2(0.0, 0.0);
	}
}

void updateFinalPositions(vec4 oldPosition, vec4 newPosition, int globalVertexIndex)
{
    positions.data[globalVertexIndex] = newPosition;
	previousPositions.data[globalVertexIndex] = oldPosition;
}

vec4 integrate(vec4 currentPosition, vec4 oldPosition, vec3 force, float dampingCoeff, float particleMass)
{
    vec4 outputPos = currentPosition;
	//outputPos.xyz = currentPosition.xyz + (1.0 - dampingCoeff) * (currentPosition.xyz - oldPosition.xyz) + force * timeStep * timeStep;
	outputPos.xyz = currentPosition.xyz + (currentPosition.xyz - oldPosition.xyz) + (force / particleMass) * timeStep * timeStep;
	return outputPos;
}

//used so that the strands don't get too long (constrained length)
/*what this method does: after a point is moved to a new position for next timeStep
because of a force, the distance between this point and adjacent point is 
most likely not the same anymore, which isn't good because we always want 
strands to remain the same length. This function helps with length correction by
compressing the two points towards each other if too far, and stretching if
too close. This function preserves the orientation of the line/vector between
the two points.
*/
void applyDistanceConstraint(int index0, int index1, float targetDistance)
{
	//index0 and 1 are always adjacent, with 0 to 1 from root to tip
    vec4 p0 = sharedPositions[index0];
	vec4 p1 = sharedPositions[index1];

	vec3 delta = p1.xyz - p0.xyz;
	float distance = max(length(delta), 1e-7);
	/* if distance = targetDistance, stretching = 0
	if distance < targetDistance, stretching < 0
	if distance > targetDistance, stretching > 0
	*/
	float stretching = 1 - targetDistance / distance;
	delta = delta * stretching;
	/* 
	case 1: current distance too long, want to pull back in
	let td = 1, d = 1.2
	stretch = 1 - 1 / 1.2 = 0.16667
	delta = 1.2 * 0.16667 = 0.2



	case 2: current distance too short, want to stretch back out
	let td = 5.3, d = 2.8
	stretch = 1 - 5.3 / 2.8 = -0.8928
	delta = 2.8 * -0.8928 = -2.5
	*/
	vec2 multiplier = constraintMultiplier(p0, p1);

	sharedPositions[index0].xyz += multiplier[0] * delta;
	sharedPositions[index1].xyz -= multiplier[1] * delta;
}

vec3 calculateWindForce(int localID, int globalID) {
    vec3 wind0 = windPyramid[0].xyz;
	// if(length(wind0) == 0 || localID < 2 || localID >= verticesPerStrand - 1) {
	//     return vec3(0.0, 0.0, 0.0);
	// }
	if(length(wind0) == 0 || localID < 1) {
	    return vec3(0.0, 0.0, 0.0);
	}
	float a = (globalID % 20) / 20.0f;
	vec3 w = a * wind0 + (1.0 - a) * windPyramid[1].xyz + a * windPyramid[2].xyz + (1.0 - a) * windPyramid[3].xyz;
	vec3 tangent = normalize(sharedPositions[localID].xyz - sharedPositions[localID + 1].xyz);
	vec3 windForce = cross(cross(tangent, w), tangent);
	return windForce;
}

//TODO: Implement bending and torsion
//bending: for localID i, get initial length between node[i-2] and node[i+2]
vec3 calculateSpringForce(vec4 currentPosition, vec4 initialPosition, int globalVertexIndex, int localID) {
	if (localID == 0) {//root vertex does not move
		return vec3(0.0f, 0.0f, 0.0f);
	}
	float restStretchDistAbove = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex - 1].xyz);
	float restStretchDistBelow = 0.0f;
	if (localID < verticesPerStrand - 1)
		restStretchDistBelow = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex + 1].xyz);
	}
	//bending rest distances
	float restBendDistAbove = 0.0f
	if (localID >= 2) {
		restBendDistAbove = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex - 2].xyz);
	}
	float restBendDistBelow = 0.0f
	if (localID < verticesPerStrand - 2) {
		restBendDistBelow = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex + 2].xyz);
	}
	//torsion rest distances
	float restTorsionDistAbove = 0.0f
	if (localID >= 3) {
		restBendDistAbove = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex - 3].xyz);
	}
	float restTorsionDistAbove = 0.0f
	if (localID < verticesPerStrand - 3) {
		restBendDistAbove = length(restPositions.data[globalVertexIndex].xyz - restPositions.data[globalVertexIndex + 3].xyz);
	}
	//stretch springs
	vec4 abovePosition = positions.data[globalVertexIndex - 1];
	vec4 belowPosition = positions.data[globalVertexIndex + 1];
	//bending springs
	vec4 aboveBending = positions.data[globalVertexIndex - 2];
	vec4 belowBending = positions.data[globalVertexIndex + 2];
	//torsion springs
	vec4 aboveTorsion = positions.data[globalVertexIndex - 3];
	vec4 belowTorsion = positions.data[globalVertexIndex + 3];


	int ks = 5000000;
	int kb = 5000;
	int kt = 5000;

	vec3 vectorStretchAbove = currentPosition.xyz - abovePosition.xyz;
	vec3 deltaStretchAbove = vectorStretchAbove * (length(vectorStretchAbove) - restStretchDistAbove);

	vec3 vectorBendAbove = currentPosition.xyz - aboveBending.xyz;
	vec3 deltaBendAbove = vectorBendAbove * (length(vectorBendAbove) - restBendDistAbove);
	
	vec3 vectorTorsionAbove = currentPosition.xyz - aboveTorsion.xyz;
	vec3 deltaTorsionAbove = vectorTorsionAbove * (length(vectorTorsionAbove) - restTorsionDistAbove);

	vec3 springForceAbove = -ks * deltaStretchAbove - kb * deltaBendAbove - kt * deltaTorsionAbove;
	 
	if (localID == verticesPerStrand - 1) {
		//no springs below, so only has springs pulling from above
		return springForceAbove;
	}
	
	
	
	vec3 vectorStretchBelow = belowPosition.xyz - currentPosition.xyz;
	vec3 deltaStretchBelow = vectorStretchBelow * (length(vectorStretchBelow) - restStretchDistBelow);
	
	vec3 vectorBendBelow = belowBending.xyz - currentPosition.xyz;
	vec3 deltaStretchBelow = vectorBendBelow * (length(vectorBendBelow) - restBendDistBelow);
	
	vec3 vectorTorsionBelow = belowTorsion.xyz - currentPosition.xyz;
	vec3 deltaTorsionBelow = vectorTorsionBelow * (length(vectorTorsionBelow) - restTorsionDistBelow);
	
	vec3 springForceBelow = -ks * deltaStretchBelow;

	return springForceAbove - springForceBelow;
}

// vec3 calculateSpringForce(vec4 currentPosition, vec4 initialPosition, int globalVertexIndex, int localID) {
// 	if (localID == 0) {
// 		return vec3(0.0f, 0.0f, 0.0f);
// 	}

// 	vec4 abovePosition = positions.data[globalVertexIndex - 1];
// 	vec4 belowPosition = positions.data[globalVertexIndex + 1];
// 	int k = 5000;

	
// 	vec3 springForceAbove = -k * (currentPosition.xyz - abovePosition.xyz);
	 
// 	if (localID == verticesPerStrand - 1) {
// 		//no springs below, so only has springs pulling from above
// 		return springForceAbove;
// 	}
	
// 	vec3 springForceBelow = -k * (belowPosition.xyz - currentPosition.xyz);
// 	return springForceAbove - springForceBelow;
// }

// vec3 calculateSpringForce(vec4 currentPosition, vec4 initialPosition, int globalVertexIndex, int localID) {
// 	int k = 500;

// 	return -k * (currentPosition.xyz - initialPosition.xyz);	 
// }

//for a specific point based on localID and globalID
void main()
{
	float particleMass = 1.0f;
	/*
	-damping force
	*/
	int phase2 = 500;
    int globalID = int(gl_GlobalInvocationID.x);
	int localID = int(gl_LocalInvocationID.y);

	if(localID >= verticesPerStrand) {
	    return;
	}

	int globalRootVertexIndex = globalID * (verticesPerStrand);
	int globalVertexIndex = globalRootVertexIndex + localID;

	vec4 currentPosition = positions.data[globalVertexIndex];
	vec4 previousPosition = previousPositions.data[globalVertexIndex];
	vec4 initialPosition = restPositions.data[globalVertexIndex];
	vec4 tangentDistance = tangentsDistances.data[globalVertexIndex];


	//if (simulationFrame == phase2) {
	//	restPositions.data[globalVertexIndex] = currentPosition;
	

	vec4 oldcurrentPosition = currentPosition;
	mat3 Rx = mat3(1, 0,          0,
				   0, cos(thetaX), -sin(thetaX),
				   0, sin(thetaX), cos(thetaX));
	
	mat3 Ry = mat3(cos(thetaY), 0, sin(thetaY),
				   0, 1,  0,
				   -sin(thetaY), 0, cos(thetaY));

	mat3 Rz = mat3(cos(thetaZ), -sin(thetaZ), 0,
				   sin(thetaZ), cos(thetaZ),  0,
				   0, 0, 1);
	
	//only roots should be rotated by rotation force
	//the other points should be moved by chain reaction from root to tip
	if (localID == 0) {
		currentPosition.xyz = Rx * Ry * Rz * currentPosition.xyz;	
	}
	restPositions.data[globalVertexIndex].xyz = Rx * Ry * Rz * restPositions.data[globalVertexIndex].xyz;
	//initialPosition.xyz = Rx * Ry * Rz * initialPosition.xyz;
	
	//Fill shared positions
	sharedPositions[localID] = currentPosition;
	barrier();

	//rotation force
	vec3 rotationForce = vec3(0.0f, 0.0f, 0.0f);
	//rotationForce = (currentPosition.xyz - oldcurrentPosition.xyz) * 70000;

	vec3 defaultForce = (initialPosition.xyz - sharedPositions[localID].xyz) * 1000;
	
	//spring and damping force
	vec3 springForce = vec3(0.0f, 0.0f, 0.0f);
	//vec3 dampingForce = vec3(0.0f, 0.0f, 0.0f);
	vec3 dampingForce = (damping * 10000) * (currentPosition-previousPosition).xyz;
	//if (simulationFrame > phase2) {
		springForce = calculateSpringForce(currentPosition, initialPosition, globalVertexIndex, localID);
	//}
	//Apply forces using Verlet integration
	if(isMovable(currentPosition)) {
		float windThreshold = 15.0;
		vec3 force;
		force = gravity + defaultForce * globalStiffness + springForce +	 calculateWindForce(localID, globalID) + rotationForce - dampingForce;
		/*
		if (windMagnitude > windThreshold) {
			force = gravity + springForce +	 calculateWindForce(localID, globalID) + rotationForce - dampingForce;
		} else {
			force = gravity + springForce + calculateWindForce(localID, globalID) + rotationForce - dampingForce + defaultForce * globalStiffness * (windThreshold - windMagnitude) / windThreshold;
		}
		*/
	    sharedPositions[localID] = integrate(currentPosition, previousPosition, force, damping, particleMass);
	}

	//Global stiffness
	/* 
	globalStiffness is a number between 0 and 1
	when globalStiffness = 1, delta = init - shared, 
		shared = shared + (init - shared),
		shared = init
	*/
	/*
	vec3 delta = globalStiffness * (initialPosition - sharedPositions[localID]).xyz;
	sharedPositions[localID].xyz += delta;
	*/
	barrier();


	//Local shape
	if(localID == 0) {//localID == 0 for root points, in other words if this is a root vertex
		//localShapeIterations is currently set to 10 in Renderer.cpp
	    for(int i = 0; i < localShapeIterations; i++) {
		    vec4 position = sharedPositions[1];
			vec4 globalRotation = globalRotations.data[globalRootVertexIndex];

			for(int localVertexIndex = 1; localVertexIndex < verticesPerStrand - 1; localVertexIndex++) {
			    vec4 positionNext = sharedPositions[localVertexIndex + 1];
				vec3 localPositionNext = refVectors.data[globalRootVertexIndex + localVertexIndex + 1].xyz;
				vec3 targetPositionNext = multQuaternionAndVector(globalRotation, localPositionNext) + position.xyz;

				vec3 localDelta = localStiffness * (targetPositionNext - positionNext.xyz);

				if(isMovable(position)) {
				    position.xyz -= localDelta;
				}

				if(isMovable(positionNext)) {
				    positionNext.xyz += localDelta;
				}

				vec4 globalRotationInv = inverseQuaternion(globalRotation);
				vec3 tangent = normalize(positionNext.xyz - position.xyz);
				vec3 localTangent = normalize(multQuaternionAndVector(globalRotationInv, tangent));
				vec3 xAxis = vec3(1.0, 0, 0);
				vec3 rotationAxis = cross(xAxis, localTangent);
				float angle = acos(dot(xAxis, localTangent));

				if(length(rotationAxis) > 0.001 && abs(angle) > 0.001) {
					rotationAxis = normalize(rotationAxis);
					vec4 localRotation = makeQuaternion(angle, rotationAxis);
					globalRotation = multQuaternionAndQuaternion(globalRotation, localRotation);
				}

				sharedPositions[localVertexIndex].xyz = position.xyz;
				sharedPositions[localVertexIndex + 1].xyz = positionNext.xyz;
				position = positionNext;
			}
	    } 
	}
	barrier();

	//Length constraints
	for(int i = 0; i < lengthConstraintIterations; i++) {//lengthConstraintIterations is set to 5
		//for debugging purposes
		bool boolApplyDistanceConstraint = false;
		if (!boolApplyDistanceConstraint){
			if(localID % 2 == 0 && localID < verticesPerStrand - 1) {
				if (simulationFrame <= phase2) {
					//applyDistanceConstraint(localID, localID + 1, tangentDistance.w);
				}
				
			}

			barrier();

			if(localID % 2 == 1 && localID < verticesPerStrand - 1) {
				if (simulationFrame <= phase2) {
					//applyDistanceConstraint(localID, localID + 1, tangentDistance.w);
				}
			}
		} else {
			if(localID % 2 == 0 && localID < verticesPerStrand - 1) {
				//if (simulationFrame <= phase2) {
					applyDistanceConstraint(localID, localID + 1, tangentDistance.w);
				//}
				
			}

			barrier();

			if(localID % 2 == 1 && localID < verticesPerStrand - 1) {
				//if (simulationFrame <= phase2) {
					applyDistanceConstraint(localID, localID + 1, tangentDistance.w);
				//}
			}
		}
	    

		barrier();
	}

	updateFinalPositions(currentPosition, sharedPositions[localID], globalVertexIndex);
}